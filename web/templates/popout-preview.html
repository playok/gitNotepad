<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview - Git Notepad</title>
    <link rel="icon" type="image/svg+xml" href="{{.basePath}}/static/favicon.svg">
    <link rel="icon" type="image/x-icon" href="{{.basePath}}/static/favicon.ico">
    <link rel="stylesheet" href="{{.basePath}}/static/css/style.css">
    <link rel="stylesheet" href="{{.basePath}}/static/lib/highlight/github.min.css" id="hljs-light">
    <link rel="stylesheet" href="{{.basePath}}/static/lib/highlight/github-dark.min.css" id="hljs-dark">
    <link rel="stylesheet" href="{{.basePath}}/static/lib/katex/katex.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
        }

        .popout-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .popout-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid hsl(var(--border));
            background: hsl(var(--muted) / 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popout-title {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin: 0;
        }

        .popout-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .popout-controls select {
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            font-size: 0.75rem;
            cursor: pointer;
        }

        .popout-content {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .popout-content.preview-pane {
            line-height: 1.7;
        }

        .connection-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius);
        }

        .connection-status.connected {
            background: hsl(var(--success) / 0.1);
            color: hsl(var(--success));
        }

        .connection-status.disconnected {
            background: hsl(var(--destructive) / 0.1);
            color: hsl(var(--destructive));
        }
    </style>
</head>
<body>
    <div class="popout-container">
        <div class="popout-header">
            <h1 class="popout-title" id="previewTitle">Preview</h1>
            <div class="popout-controls">
                <span class="connection-status connected" id="connectionStatus">Connected</span>
                <select id="themeSelect">
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                    <option value="dark-high-contrast">Dark (High Contrast)</option>
                    <option value="dark-cyan">Dark (Cyan)</option>
                </select>
            </div>
        </div>
        <div class="popout-content preview-pane" id="previewContent">
            <p style="color: hsl(var(--muted-foreground)); text-align: center; padding: 2rem;">
                Waiting for content from editor...
            </p>
        </div>
    </div>

    <script src="{{.basePath}}/static/lib/marked.min.js"></script>
    <script src="{{.basePath}}/static/lib/highlight/highlight.min.js"></script>
    <script src="{{.basePath}}/static/lib/katex/katex.min.js"></script>
    <script src="{{.basePath}}/static/lib/katex/auto-render.min.js"></script>
    <script src="{{.basePath}}/static/lib/asciidoctor.min.js"></script>
    <script>
        const basePath = '{{.basePath}}';
        const themes = ['light', 'dark', 'dark-high-contrast', 'dark-cyan'];

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            let theme = 'light';

            if (savedTheme && themes.includes(savedTheme)) {
                theme = savedTheme;
            } else if (prefersDark) {
                theme = 'dark';
            }

            setTheme(theme);
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);

            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.value = theme;
            }

            // Toggle highlight.js stylesheets
            const hljsLight = document.getElementById('hljs-light');
            const hljsDark = document.getElementById('hljs-dark');
            const isDark = theme !== 'light';

            if (hljsLight) hljsLight.disabled = isDark;
            if (hljsDark) hljsDark.disabled = !isDark;
        }

        // Initialize marked
        function initMarked() {
            if (typeof marked !== 'undefined') {
                const renderer = new marked.Renderer();
                // Open links in new tab
                renderer.link = function(href, title, text) {
                    if (typeof href === 'object') {
                        title = href.title;
                        text = href.text;
                        href = href.href;
                    }
                    const titleAttr = title ? ` title="${title}"` : '';
                    return `<a href="${href}"${titleAttr} target="_blank" rel="noopener noreferrer">${text}</a>`;
                };
                marked.setOptions({
                    gfm: true,
                    breaks: true,
                    renderer: renderer
                });
            }
        }

        // Render content
        function renderContent(content, noteType) {
            const previewContent = document.getElementById('previewContent');

            if (noteType === 'markdown') {
                previewContent.innerHTML = marked.parse(content);
            } else if (noteType === 'asciidoc') {
                if (typeof Asciidoctor !== 'undefined') {
                    try {
                        const asciidoctor = Asciidoctor();
                        // Use MemoryLogger to suppress console warnings
                        if (typeof asciidoctor.MemoryLogger !== 'undefined') {
                            const memoryLogger = asciidoctor.MemoryLogger.create();
                            asciidoctor.LoggerManager.setLogger(memoryLogger);
                        }
                        previewContent.innerHTML = asciidoctor.convert(content, {
                            safe: 'safe',
                            attributes: {
                                'showtitle': true,
                                'icons': 'font'
                            }
                        });
                    } catch (e) {
                        console.error('AsciiDoc rendering error:', e);
                        previewContent.innerHTML = '<pre>' + escapeHtml(content) + '</pre>';
                    }
                } else {
                    previewContent.innerHTML = '<pre>' + escapeHtml(content) + '</pre>';
                }
            } else {
                previewContent.innerHTML = '<pre>' + escapeHtml(content) + '</pre>';
            }

            // Open links in new tab
            previewContent.querySelectorAll('a[href]').forEach((link) => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
            });

            // Apply syntax highlighting
            previewContent.querySelectorAll('pre code').forEach((block) => {
                if (typeof hljs !== 'undefined') {
                    hljs.highlightElement(block);
                }
            });

            // Render math
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(previewContent, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Listen for messages from parent window
        window.addEventListener('message', (e) => {
            if (e.data && e.data.type === 'preview-update') {
                const { content, noteType, title, theme } = e.data;

                // Apply theme from parent window
                if (theme) {
                    setTheme(theme);
                }

                // Update title
                const titleEl = document.getElementById('previewTitle');
                if (titleEl && title) {
                    titleEl.textContent = title;
                    document.title = `${title} - Preview`;
                }

                // Render content
                renderContent(content, noteType);

                // Update connection status
                updateConnectionStatus(true);
            } else if (e.data && e.data.type === 'theme-update') {
                // Handle theme-only update
                if (e.data.theme) {
                    setTheme(e.data.theme);
                }
            }
        });

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (status) {
                status.textContent = connected ? 'Connected' : 'Disconnected';
                status.className = 'connection-status ' + (connected ? 'connected' : 'disconnected');
            }
        }

        // Notify parent window when closing
        window.addEventListener('beforeunload', () => {
            if (window.opener) {
                window.opener.postMessage('popout-closed', '*');
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initMarked();

            // Theme selector - sync with parent window
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const newTheme = e.target.value;
                    setTheme(newTheme);
                    // Notify parent window of theme change
                    if (window.opener && !window.opener.closed) {
                        window.opener.postMessage({
                            type: 'popout-theme-change',
                            theme: newTheme
                        }, '*');
                    }
                });
            }

            // Check if opener is still available
            setInterval(() => {
                if (!window.opener || window.opener.closed) {
                    updateConnectionStatus(false);
                }
            }, 1000);

            // Request initial content from parent
            if (window.opener) {
                window.opener.postMessage('popout-ready', '*');
            }
        });
    </script>
</body>
</html>
